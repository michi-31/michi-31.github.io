---
title: "3.データ変換"
date: "2024-10-02"
execute: 
  error: true
  cache: true
format:
  html: 
    slide-level: 2
    toc: true
---

# 1.目的
データフレームの変換するための主要ツールについて整理する。

### 準備
- dplyer（ディープライ）パッケージ: ggplot2と同様、tidyverseのコアメンバー
- nycflights13: 2013年にニューヨーク市を出発した336,776便のフライトについてのデータセット
```{r}
library(nycflights13)
library(tidyverse)
```
```{r}
glimpse(flights)
```
- <int>: 整数の省略形
- <dbl>: 倍精度（実数）の省略形
- <chr>: 文字の省略形
- <dttm>: 日時の省略形

### パイプ: |>
パイプ|>は、左側のものを受け取り、右側の関数に渡す処理を行うもの。  
プログラミングの文脈では、「次に何をするか（then）」の意味で使われる。

  - x |> f(y)  = f(x, y)
  - x |> f(y) | g(z) = g(f(x, y), z)
```{r}
flights |>  # データを次の関数の引数として渡す
  filter(dest == "IAH") |>  # 「IAH」へのフライトだけをフィルタリング
  group_by(year, month, day) |>  # 年、月、日でグルーピング
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)  # 到着遅延の平均を計算
  )
```
filter(dest == "IAH")で、行き先（dest）が「IAH」（ジョージ・ブッシュ・インターコンチネンタル空港）のフライトを抽出する。  

group_by(year, month, day)で、フライトのデータを年、月、日でグループ化し、同じ日に出発したフライトのデータを一つにまとめる。  

summarize(arr_delay = mean(arr_delay, na.rm = TRUE))で、各グループの到着遅延時間（arr_delay）の平均を計算する。  
また、na.rm = TRUEにより、NA（欠損値）は計算から除外される。

#  2.行
### filter()
- filter(): 列の値に基づいて行を選択する関数  
なお、既存のflightsデータセットは変更されない。  

第１引数はデータフレームで、第２引数以降は行を選択するために真でなければならない条件を設定する。

120分以上遅れて出発したフライトを抽出
```{r}
filter(flights, dep_delay > 120)
```
パイプ演算子を用いた表記
```{r}
flights |>
  filter(dep_delay > 120)
```
- &: and条件
```{r}
flights |>
  filter(month == 1 & day == 1)
```
- |: or条件
```{r}
flights |>
  filter(month == 1 | day == 1)
```
- %in%: |と==の組み合わせ  
変数が右辺の値の１つに等しい行を保持する。
```{r}
flights |>
  filter(month %in% c(1, 2))
```

### arange()
arrange()関数は、列の値に基づいて行の順序を変更します。
```{r}
flights |>
  arrange(year, month, day, dep_time)
```
- desc(): データを降順で並び替え
```{r}
flights |>
 arrange(desc(dep_delay))
```

### distinct()
- distinct(): 主に行に対して動作してデータセット内の一意の行を見つける関数
```{r}
flights |>
  distinct(origin, dest)
```
- .keep_all = TRUE: 他の列を保持するオプション
```{r}
flights |>
  distinct(origin, dest, .keep_all = TRUE)
```

### count()
- count(): データセット内の特定の行の出現数を数える関数
```{r}
flights |>
  count(origin, dest)
```
- sort = TRUE: 出現数の降順に並び替えるオプション
```{r}
flights |>
  count(origin, dest, sort = TRUE)
```

# 練習問題
### 1. 次の条件を満たす便を検索する
到着が２時間以上遅れた便
```{r}
flights |>
  filter(arr_delay >= 120)
```
ヒューストン（"IAH"または"HOU"）行きの便
```{r}
flights |>
  filter(dest == "IAH" | dest == "HOH")
```
ユナイテッド航空、アメリカン航空、デルタ航空便
```{r}
flights |>
  filter(carrier %in% c("UA", "AA", "DL"))
```
夏（７～９月）に出発した便
```{r}
flights |>
  filter(month %in% c(7, 8, 9))
```
２時間以上遅れて到着したものの、出発は遅れなかった便
```{r}
flights |>
  filter(arr_delay >= 30 & dep_delay == 0)
```
到着が少なくとも１時間遅れたが、フライト中に30分遅れた便
```{r}
flights |>
  filter(arr_delay >= 60 & (dep_delay - arr_delay) >= 30)
```

### 2.出発の遅れが最も長いフライトを見つける
```{r}
flights |>
  arrange(desc(dep_delay))
```

### 3.最も早いフライトを見つける
```{r}
flights |>
  arrange(distance / air_time)
```

### 4.2013年のすべての日にフライトがあったか調べる
```{r}
flights |>
  filter(year == 2013) |>
  group_by(year, month, day)
```

### 5.どの便が最も遠い距離を移動したか、最も短い距離を移動したか調べる
```{r}
flights |>
  arrange(desc(distance))
```
```{r}
flights |>
  arrange(distance)
```

### 6.filter()とarrange()の両方を使う場合、どちらを先に使用したかは問題になるか
arrange()は、データを並び替えているだけのため、フィルタリングを行う場合はfilter()を先に使用する。

# 3.列
### mutate()
- mutate(): 既存の列から計算される新しい列を追加する関数  
- .before: 新たに作成した列を最初の列に追加するオプション
```{r}
flights |>
  mutate(
    gain = dep_delay - arr_delay, # 得た時間を計算して列を追加
    speed = distance / air_time * 60, # 速度を計算して列を追加
    .before = 1 # 新たに作成した列を最初の列に追加
  )
```
- after: 新しい列を最後尾に追加する  
.beforeも.afterも位置の代わりに変数を指定することができる。
```{r}
flights |>
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .after = day # dayの後に新たに作成した列を追加
  )
```
- .keep = "used": mutate()で新たに作成された列だけを保持し、使用されていない元の列は削除するオプション  

他の列を保持したい場合は、.keep = "all"や.keep = "unused"などのオプションを使用できる。
```{r}
flights |>
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .keep = "used" # 新たに作成した列だけを保持する
  )
```

### select()
- select(): 変数名（列）を指定して必要なサブセットを抽出する関数  

変数名を指定
```{r}
flights |>
  select(year, month, day)
```
yearからdayまでの列を選択
```{r}
flights |>
  select(year:day)
```
yearからdayまで以外の列を選択
```{r}
flights |>
  select(!year:day)
```
文字であるすべの列を選択
```{r}
flights |>
  select(where(is.character))
```
- start_with(abc): abcから始まる名前にマッチする列を選択する関数
```markdown
select(starts_with("abc"))
```
- select("新しい名前" = "古い名前"): 変数名を変更して表示する関数
```{r}
flights |>
  select(tail_num = tailnum)
```

### rename()
- rename("新しい名前" = "古い名前"): 既存のすべての変数を保持し、いくつかの変数の名前を変更して表示する関数
```{r}
flights |>
  rename(tail_num = tailnum)
```

### relocate()
- relocate(): 重要な変数を前に移動する関数
```{r}
flights |>
  relocate(time_hour, air_time)
```
.beforeと.afterオプションを使って配置する場所を指定
```{r}
flights |>
  relocate(year:dep_time, .after = time_hour)
flights |>
  relocate(starts_with("arr"), .before = time_hour)
```

# 練習問題
### 1.dep_time, sched_dep_time, dep_delayを比較
select()を用いて特定の変数（列）のサブセットを抽出する。  

これらの変数には、「dep_time - sched_dep_time = dep_delay」の関係がある。
```{r}
flights |>
  select(dep_time, sched_dep_time, dep_delay)
```

### 2.dep_time, dep_delay, arr_time, arr_delayを抽出する方法
select()関数を用いて変数名で指定する。
```{r}
flights |>
  select(dep_time, dep_delay, arr_time, arr_delay)
```
distinct()関数を用いて変数名で指定する。
```{r}
flights |>
  distinct(dep_time, dep_delay, arr_time, arr_delay)
```

### 3.select()で同じ変数名を複数回指定した結果
２回目以降は認識されない。
```{r}
flights |>
  select(dep_time, dep_delay, dep_time, dep_time)
```

### 4.any_of()関数の役割
- any_of(): データセットを調べて、一致するものを選択する関数
```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")

flights |>
  select(any_of(variables)) # variablesとflightsに一致する列を抽出する
```

### 5.selectのヘルパー関数
- contains(): 大文字と小文字を区別せずに列名をフィルタリングする関数
```{r}
flights |>
  select(contains("TIME")) # TIMEやtimeなど、大文字小文字に関わらず列名をフィルタリングする
```
```{r}
flights |>
  select(contains("time"))
```

### 6.air_timeの名前をair_time_minに変更し、データフレームの先頭に移動
```{r}
flights |>
  rename(air_time_main = air_time) |>
  relocate(air_time_main)
```

### 7.エラー修正
select()関数でフィルタリングをしてから並び替えを行おうとするため、エラーが発生する。
```markdown
flights |>
  select(tailnum) |>
  arrange(arr_delay) # arr_delayが存在しない
```
先にarrange()関数で並び替えを行うよう修正する。
```{r}
flights |>
  arrange(arr_delay) |>
  select(tailnum) 
```


# 4.パイプ: |>
|> は一般的に「パイプ演算子」と呼ばれ、データをある関数の入力として渡すために使う。

- 関数の合成: 一つの関数の出力を別の関数の入力として使うことができます。例えば、x |> f |> g は、g(f(x)) と同等。

- コードの可読性向上: パイプを使うことで、データの流れを視覚的に表現でき、読みやすくなることがある。

ヒューストンのIAH空港への最速便を見つける場合
```{r}
flights |>
  filter(dest == "IAH") |>
  mutate(speed = distance / air_time * 60) |>
  select(year:day, dep_time, carrier, flight, speed) |>
  arrange(desc(speed))
```

# 5.グループ
### group_by()
データセットを意味のあるグループに分割する。
```{r}
flights |>
  group_by(month) # 月でグループ化
```

### summarize()
グループ化した上で１つの要約統計量を計算する。
```{r}
flights |>
  group_by(month) |>
  summarize(
    avg_delay = mean(dep_delay)
  )
```
- na.rm = TRUE: 欠損値を無視するように指示するオプション
```{r}
flights |>
  group_by(month) |>
  summarize(
    delay = mean(dep_delay, na.rm = TRUE)
  )
```
- n = n(): 各グループの行数を返すオプション
```{r}
flights |>
  group_by(month) |>
  summarize(
    delay = mean(dep_delay, na.rm = TRUE),
  n = n()
  )
```

### slice()
- slice(): 各グループ内で特定の行を抽出する関数

例えば、各グループの１行目をとる場合、以下のように指定する。
```markdown
def |> slice_head(n = 1)
```

目的地ごと、到着が最も遅れたフライトを検索する。  
ただし、slice_max()は最大値を保持するため、n = 1には重複がある。
```{r}
flights |>
  group_by(dest) |>
  slice_max(arr_delay, n = 1) |>
  relocate(dest) # destを前に移動
```
- with_ties = FALSE: グループごと１行だけ抽出するオプション  
with_ties = FALSEを指定することで、同じ最大値を持つ行が複数ある場合でも、1行だけが選ばれる。
```{r}
flights |>
  group_by(dest) |>
  slice_max(arr_delay, n = 1, with_ties = FALSE) |>
  relocate(dest)
```

### ungroup()
- ungroup(): グループ化を解除する関数

year, month, dayでグループ化を行い、dailyに格納する。
```{r}
daily <- flights |>
  group_by(year, month, day)
# グループ化されたデータを表示
daily
# グループ化を解除して上書き
daily <- daily |> ungroup()
```

グループ化されていないデータフレームを要約すると、すべての行を１つのグループに属するものとして扱う。
```{r}
daily |>
  ungroup()  |>
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    flignts = n()
  )
```

### .by
- .by: データを特定の列でグループ化しながら操作を実行する関数  

.byを使用する場合、グループ化は自動的に解除されるため、操作が終わった後に手動でグループ化を解除するためのungroup()を呼び出す必要はない。

```{r}
flights |>
  summarize(
    delay = mean(dep_delay, na.rm = TRUE),
    n = n(),
    .by = month # monthでグループ化
  )
# グループ化を解除する必要はない
```

複数の変数でグループ化する場合はベクトルを用いる。
```{r}
flights |>
  summarize(
    delay = mean(dep_delay, na.rm = TRUE),
    n = n(),
    .by = c(origin, dest) # originとdestでグループ化
  )
```

# 練習問題
### 1.平均遅延が最悪な航空会社を確認する
```{r}
  flights |>
    group_by(carrier, dest) |>
    summarize(
      delay = mean(arr_delay, na.rm = TRUE),
      n = n()
    ) |>
    arrange(desc(delay))
```
```{r}
flights |>
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n(),
    .by = c(carrier, dest)
  ) |>
  arrange(desc(delay))
```

### 2.目的地ごとに、出発時に最も遅延した便
```{r}
flights |>
  group_by(dest) |>
  slice_max(dep_delay, n = 1) |>
  relocate(dest)
```

### 3.１日の遅延の変化
時間帯ごとの平均到着遅延時間を確認したところ、時間帯が遅くなるにつれて、遅延が増えることがわかる。
```{r}
flights |>
  group_by(hour) |>
  summarize(
    avg_delay = mean(arr_delay, na.rm = TRUE)
  ) |>
  ggplot(aes(x = hour, y = avg_delay)) +
  geom_point() + 
  geom_smooth(method = "loess")
```

### 4.slice_min()のnに負の値を与えた結果
- n = 1: destごと、arr_delayの最小値を１つ抽出する
```{r}
flights |>
  group_by(dest) |>
  slice_min(arr_delay, n = 1) |> # 各グループから到着遅延が最小の行を1行だけ抽出
  relocate(dest, arr_delay) # destとarr_delay先頭に移動する
```
- n = -1: フィルタリングが働かず、全ての値が表示される
```{r}
flights |>
  group_by(dest) |>
  slice_min(arr_delay, n = -1) |>
  relocate(dest, arr_delay)
```

### count関数とsort引数
- sort = TRUE: 出発地と目的地ごとにフライト数をカウントし、降順にソートするオプション
```{r}
flights |>
  count(origin, dest, sort = TRUE)  # カウントされた結果を降順にソートする
```
- sort = FALSE: 出発地と目的地ごとのフライト数をカウントし、アルファベット順（デフォルトの順序）で表示するオプション
```{r}
flights |>
  count(origin, dest, sort = FALSE) 
```

### 6.出力結果の検証
```{r}
df <- tibble(
  x = 1:5,
  y = c("a", "b", "a", "a", "b"),
  z = c("K", "K", "L", "L", "K")
)
  
df
```
データフレームがy列の値（"a" と "b"）に基づいてグループ化されれる。  
この時点では、実際の計算は行われず、データのグループ化情報が追加される。
```{r}
df |>
  group_by(y)
```
データフレームがy列の値（"a" と "b"）に基づいて並び替わる。  
なお、降順にする場合はdesc()を用いる。 
```{r}
df |>
  arrange(y)
```
データフレームがy列の値（"a" と "b"）に基づいてグループ化され、それぞれのグループに対するxの平均値が表示される。 
```{r}
df |>
  group_by(y)|>
  summarize(x = mean(x))
```
dfデータフレームをyとzの列でグループ化し、各グループのx列の平均を計算する。
```{r}
df |>
  group_by(y, z)|>
  summarize(x = mean(x))
```
- .groups = "drop": 操作終了後にグループ化を解除するオプション
```{r}
# .groups = "drop"を使う場合
df_summary <- df |>
  group_by(y, z)|>
  summarize(x = mean(x), .groups = "drop")

# ungroup()を使う場合
df_summary <- df |>
  group_by(y, z)|>
  summarize(x = mean(x)) |>
  ungroup()
```
グループ化された各組み合わせの平均が計算され、新しいデータフレームが返される。  
グループの数だけの行が生成され、元のデータは集約される。
```{r}
df |>
  group_by(y, z)|>
  summarize(x = mean(x))
```
元のデータフレームに新しい列を追加し、各行に対してそのグループのxの平均を計算する。  
元のデータの行数は変わらず、各グループの平均値が各行に反映される。
```{r}
df |>
  group_by(y, z)|>
  mutate(x = mean(x))
```

### 6.集計とサンプルサイズ
Lahmanパッケージの野球データでプレイヤーがヒット（H）した割合と打数（AB）を比較する。

- Lahman::Batting: LahmanパッケージのBattingデータセットを直接指定して使用。
- library(Lahman): Lahmanパッケージを読み込み、全ての関数やデータを使用可能にする。

```{r}
batters <- Lahman::Batting |>
  group_by(playerID) |>
  summarize(
    performance = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    n = sum(AB, na.rm = TRUE)
  )

batters
```
```{r}
batters |>
  filter(n > 100) |>
  ggplot(aes(x = n, y = performance)) + 
  geom_point(alpha = 1/ 10) + 
  geom_smooth(se = FALSE)
```
