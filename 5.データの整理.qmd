---
title: "5.データの整理"
date: "2024-10-01"
execute: 
  error: true
  cache: true
format:
  html: 
    slide-level: 2
    toc: true
---

# 目的
整理データ（tidy data）と呼ばれるシステムを使ってデータの整理方法を学びます。 

# 1.準備
データ整理のツールtidyrを使用するため、tidyverseをロードします。
```{r}
library(tidyverse)
```
# 練習問題
# 1.データセットの行列を調べる
```{r}
glimpse(table1)
glimpse(table2)
glimpse(table3)
```
# 2.table2, table3についてrateを計算する

```{r}
table1 |>
  mutate(rate = cases / population * 10000)
```
- sapply(): リストやベクトルに対して関数を適用し、結果をベクトルや行列に変換する
```{r}
table2 |>
  filter(type %in% c("cases", "population")) |>
  group_by(country, year) |>
  summarize(
    total_cases = sum(count[type == "cases"]),
    total_population = sum(count[type == "population"]),
  ) |>
  mutate(rate = (total_cases / total_population) * 10000)

rate
```

```{r}
table3 |>
  mutate(
    rate = sapply(rate,
    function(x) eval(parse(text = x))) * 10000) |>
  group_by(country, year)  
```

# 3.データを伸ばす
2000年のビルボードの曲のランキングを記録したbillbordデータセットを用いて、列に変数、行に観測値を持つ整理した形式にデータを「ピボット」します。  

ピボットとは、横持ち形式（ワイドフォーマット）のデータを縦持ち形式（ロングフォーマット）に展開することや、形式変換、集計を行う操作を指します（その逆も）。
```{r}
head(billboard)
```
- cols: ピボットする列（変数から除外する列）を指定する
- names_to: 列に格納されている変数に名前を付ける
- values_to:  値に格納されている変数に名前を付ける
```{r}
billboard |>
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    values_to = "rank"
  )
```
pivot_longer()にvalue_drop_na = TRUEを設定して、欠損値を取り除くよう指定します。
```{r}
billboard |>
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  )
```
mutate()とreadr::parse_number()を用いて、文字列を数値に変換します。
```{r}
billboard_longer <- billboard |>
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  ) |>
   mutate(
    week = parse_number(week)
   )
```

曲のランキングが週の経過とともにどのように変化するのかを可視化します。

scale_y_reverse()は、y軸を逆にするための関数です。  
通常、ランキングは小さい値が上位（例えば1位）、大きい値が下位ですが、この関数を使うことで上位のランクが上に表示されます。
```{r}
billboard_longer |>
  ggplot(aes(x = week, y = rank, group = track)) +
  geom_line(alpha = 0.25) + 
  scale_y_reverse()
```

### ピボットの仕組み

idがA,B,Cの３人の患者がいて、それぞれの患者で２回の血圧測定を行うとします。  
```{r}
df <- tribble(
    ~id,  ~bp1,  ~bp2,
    "A",   100,   120,  
    "B",   140,   115,
    "C",   120,   125
)

df
```

新しいデータセットには、id, measurement（列）, value（値）の３つの変数を持たせます。
```{r}
df |>
  pivot_longer(
    cols = bp1:bp2,
    names_to = "measurement",
    values_to = "value"
  )
```

世界保健機関によって収集されたデータセットwho2を用いて、データをロング形式に変換します。  

新しいデータセットには、国と年、診断方法、性別、年齢層、患者数の６つの変数を持たせます。
```{r}
head(who2)

who2 |>
  pivot_longer(
    cols = !(country:year),
    names_to = c("diagnosis", "gender", "age"),
    names_sep = "_",
    values_to = "count"
  )
```

５つの家族に関するデータが含まれているデータセットhouseholdを用いて、データをロング形式に変換します。  

列名に２つの変数名（dob, name）と他の値があるため、names_to = で".value"を設定し、２つの構成要素に分割します。
なお、子供が１人だけの場合など処理によって欠落した変数が作成されるため、values_drop_na = TRUEで欠損値を取り除きます。
```{r}
head(household)

household |>
  pivot_longer(
    cols = !family,
    names_to = c(".value", "chiled"),
    names_sep = "_",
    values_drop_na = TRUE
  )
```

# 4.データを広げる
pivoto_wider()を用いて、１つの観測が複数の行に分割されている場合を考えます。  

米国のCMSから患者の経験に関するデータを収集したデータセットを使います。  

distinct(measure_cd, measure_title)で、ユニークな組み合わせを表示します。
```{r}
head(cms_patient_experience)

cms_patient_experience|>
  distinct(measure_cd, measure_title)
```
- pivot_wider(): データをロング形式からワイド形式に変換します。
  - id_cols = starts_with("org"): "org" で始まる識別子列を指定します。これらの列はピボット後もそのまま残ります。
  - names_from = measure_cd: measure_cd 列の値が新しい列名になります。
  - values_from = prf_rate: 新しい列に入る値は prf_rate 列から取得します
```{r}
cms_patient_experience|>
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  )
```

### pivot_wider()の仕組み

```{r}
df2 <- tribble(
    ~id,  ~measurement,  ~value,
    "A",         "bp1",     100,  
    "B",         "bp1",     140,
    "B",         "bp2",     115,
    "A",         "bp2",     120,  
    "A",         "bp3",     105 
)

df
```

value列から値を取り出して、measurement列から列名を取得します。
```{r}
df2 |>
  pivot_wider(
    names_from = measurement,
    values_from = value
  )
```

新しい列名は、measurementの一意の値になります。

- distinct(measurement): ここで、measurement 列のユニークな値を取得します。
- pull(): これにより、measurement 列の値がベクトルとして返されます。
```{r}
df2 |>
  distinct(measurement) |>
  pull()
```
- select(-measurement, -value): measurement 列と value 列を削除します。
- distinct(): 重複を排除します。
- mutate(x = NA, y = NA, z = NA): 新しい列 x, y, z を追加し、すべての値を NA で初期化します。
```{r}
df2 |>
  select(-measurement, -value) |>
  distinct() |>
  mutate(x = NA, y = NA, z = NA)
```